#!/usr/bin/perl

# Run the FlyMine production build and dump the database occasionally
# Targets are listed at the end of the script
# The database to dump will be found by reading the properties from $HOME/flymine.properties

use strict;
use warnings;

use Expect;
use Getopt::Std;

my $ant_command = "ant";

my $dump_file_prefix;
my $dump_host;

sub usage
{
  die <<'EOF';
usage:
  $0 dump_host dump_file_prefix
or
  $0 -v dump_host dump_file_prefix

flags:
 -v is passed to ant
 -r attempt to restart by reading the last dump file

example:
  $0 /tmp/production_dump
EOF
}

my $verbose = 0;
my $restart = 0;

my %opts = ();

getopts('vr', \%opts);

if ($opts{v}) {
  $verbose = 1;
}

if ($opts{r}) {
  $restart = 1;
}

if (@ARGV == 2) {
  $dump_host = $ARGV[0];
  $dump_file_prefix = $ARGV[1];
} else {
  usage;
}

my $log_file = "pbuild.log";

open LOG, ">>$log_file" or die "can't open $log_file: $!\n";
my $old_handle = select(LOG);
$| = 1; # autoflush
select $old_handle;


my $flymine_properties = "$ENV{HOME}/flymine.properties";
my @dump_command = qw[pg_dump -c];
my @psql_command = qw[psql -q];

sub log_message
{
  my $message = shift;
  my $verbose = shift;

  if (defined $message) {
    print LOG "$message\n";
    if (defined $verbose && $verbose) {
      print STDERR "$message\n";
    }
  } else {
    print LOG "\n";
  }
}

sub log_and_print
{
  log_message shift, 1;
}

# run a command and exit the script if it returns a non-zero
sub run_and_check_status
{
  my $command_name = $_[0];

  log_and_print `date`, "\n\n";
  log_and_print "starting command: @_\n";

  open F, "@_ |" or die "can't run @_: $?\n";

  while (<F>) {
    chomp;
    log_message "  [$command_name] $_";
  }

  log_and_print `date`, "\n\n";
  log_and_print "finished\n\n";

  close F;

  if ($? != 0) {
    log_and_print "failed with exit code $?: @_\n";
    print STDERR "check log: $log_file\n";
    exit $?;
  }
}

# gets a value from a properties file
# usages: get_prop_val prop_name file_name
sub get_prop_val
{
  my $key = shift;
  my $file = shift;

  open F, "$file" or die "cannot open $file: $!\n";

  my $ret_val;

  while (my $line = <F>) {
    if ($line =~ /$key=(.*)/) {
      $ret_val = $1;
    }
  }

  close F;

  return $ret_val;
}

sub dump_db
{
  my $db = shift;
  my $user = shift;
  my $pass = shift;
  my $host = shift;
  my $out_file = shift;

  my @params = ('-U', $user, '-h', $host, '-W', '-f', $out_file, $db);

  log_and_print `date`, "\n\n";
  log_and_print "\ndumping: @dump_command @params\n";



  my $exp = new Expect;

  $exp->raw_pty(1);
  $exp->spawn("ssh", $dump_host, "@dump_command @params; echo __DUMP_FINISHED__")
    or die "Cannot spawn @dump_command @params: $!\n";

  $exp->expect(10, 'Password: ');
  $exp->send("$pass\n");
  $exp->expect(9999999, '__DUMP_FINISHED__\n');
  $exp->soft_close();
  log_and_print `date`, "\n\n";
  log_and_print "finished dump\n\n";
}

sub load_db
{
  my $db = shift;
  my $user = shift;
  my $pass = shift;
  my $host = shift;
  my $in_file = shift;

  my @params = ('-U', $user, '-h', $host, '-f', $in_file, $db);

  log_and_print `date`, "\n\n";
  log_and_print "\nloading: @psql_command @params\n";

  my $exp = new Expect;

  $exp->raw_pty(1);
  $exp->spawn("ssh", $dump_host, "@psql_command @params; echo __LOAD_FINISHED__")
    or die "Cannot spawn @psql_command @params: $!\n";

  $exp->expect(10, 'Password: ');
  $exp->send("$pass\n");
  $exp->expect(9999999, '__LOAD_FINISHED__\n');
  $exp->soft_close();
  log_and_print `date`, "\n\n";
  log_and_print "finished load\n\n";
}

sub get_actions
{
  my @actions = ();

  while (my $line = <DATA>) {
    if ($line =~ m{
                   ^\s*\#
                   |
                   ^\s*$
                 }x) {
      next;
    }

    my ($action_type, @args) = split " ", $line;

    $action_type =~ s/:$//;

    push @actions, {type => $action_type, args => [@args]};
  }

  return @actions;
}

# find the last existing dump file
sub get_restart_dump_suffix
{
  my ($dump_file_prefix, @actions) = @_;

  my %remote_suffixes = ();

  open REMOTE, qq{ssh $dump_host "ls -1 $dump_file_prefix.*"|};

  while (my $line = <REMOTE>) {
    chomp $line;
    if ($line =~ /$dump_file_prefix.(.*)/) {
      $remote_suffixes{$1} = 1;
    }
  }

  my $restart_dump_suffix = undef;

  for my $action (@actions) {
    my $action_type = $action->{type};
    my @action_args = @{$action->{args}};

    if ($action_type eq 'dump') {
      if (exists $remote_suffixes{$action_args[0]}) {
        $restart_dump_suffix = $action_args[0];
      }
    }
  }

  return $restart_dump_suffix;
}

my $prod_host = get_prop_val "db.production.datasource.serverName", $flymine_properties;
my $prod_db = get_prop_val "db.production.datasource.databaseName", $flymine_properties;
my $prod_user = get_prop_val "db.production.datasource.user", $flymine_properties;
my $prod_pass = get_prop_val "db.production.datasource.password", $flymine_properties;

log_message "read properties:";
log_message "  prod_host: $prod_host";
log_message "  prod_db: $prod_db";
log_message "  prod_user: $prod_user";
log_message "  prod_pass: $prod_pass";
log_message;

my @actions = get_actions();

my $restart_dump_suffix = undef;

if ($restart) {
  $restart_dump_suffix = get_restart_dump_suffix($dump_file_prefix, @actions);

  my $dump_file_name = "$dump_file_prefix.$restart_dump_suffix";

  if (defined $restart_dump_suffix) {
    log_and_print "restarting from $dump_file_name\n";
    load_db $prod_db, $prod_user, $prod_pass, $prod_host, $dump_file_name;
  } else {
    warn "no dump file found with prefix $dump_file_prefix\n";
  }
}

my $seen_start_action = 0;

if (!$restart || !defined $restart_dump_suffix) {
  # always start at the beggining of the command list if we aren't restarting
  $seen_start_action = 1;
}

for my $action (@actions) {
  my $action_type = $action->{type};
  my @action_args = @{$action->{args}};

  if ($seen_start_action) {
    if ($action_type eq 'run') {
      if ($verbose) {
        run_and_check_status $ant_command, "-v", @action_args;
      } else {
        run_and_check_status $ant_command, @action_args;
      }
    } else {
      if ($action_type eq 'dump') {
        if (@action_args != 1) {
          die "dump: needs one parameter at: $action: @action_args\n";
        }
        dump_db $prod_db, $prod_user, $prod_pass, $prod_host, "$dump_file_prefix.$action_args[0]";
      } else {
        die qq{unknown action "$action_type"\n};
      }
    }
  } else {
    if ($action_type eq 'dump' && $action_args[0] eq $restart_dump_suffix) {
      $seen_start_action = 1;
    }
  }
}



__END__

# lines beginning with "run:" list ant targets to run
# "dump:" lines give the suffix of the postgresql dump file
# actions are executed in order

run: create-production-model compile-genomic-model jar-genomic build-db-production load-static-flymine

dump: static

run: build-ensembl-anopheles-production

dump: anopheles

run: build-uniprot-production

dump: uniprot

run: build-flybase-production

dump: drosophila

run: build-go-production build-psi-production build-rnai-production
run: build-phenotype-production build-orthologues-production build-protein_structure-production

dump: load-stage-1

run: build-flyreg-production
run: build-long_oligo-production
run: build-tiling_path-production

dump: load-stage-2

run: build-drosdel-production

dump: load-stage-3-drosdel

run: read-flybase-chromosome-fasta calculate-locations
run: create-references
run: update-orthologues make-spanning-locations create-chromosome-locations-and-lengths
run: create-indexes-production-attribute
run: set-collection-counts set-name-and-wildtypefunction

dump: postprocess-1

run: create-overlap-relations

dump: postprocess-2-overlap

run: create-symmetrical-relation-references transfer-sequences read-flybase-cds-fasta
run: create-flybase-to-uniprot-refs update-publications

dump: postprocess-3

