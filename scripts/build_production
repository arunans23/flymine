#!/usr/bin/perl

# Run the FlyMine production build and dump the database occasionally
# Targets are listed at the end of the script
# The database to dump will be found by reading the properties from $HOME/flymine.properties

use strict;
use warnings;

use Expect;

my $dump_file_prefix;
my $dump_host;

sub usage
{
  die <<'EOF';
usage:
  $0 dump_host dump_file_prefix
or
  $0 -v dump_host dump_file_prefix

the -v flag is passed to ant

example:
  $0 /tmp/production_dump
EOF
}

my $verbose = 0;

if (@ARGV > 0) {
  if ($ARGV[0] eq '-v') {
    $verbose = 1;
    shift;
  }
}

if (@ARGV == 2) {
  $dump_host = $ARGV[0];
  $dump_file_prefix = $ARGV[1];
} else {
  usage;
}

my $log_file = "pbuild.log";

open LOG, ">>$log_file" or die "can't open $log_file: $!\n";
my $old_handle = select(LOG);
$| = 1; # autoflush
select $old_handle;


my $flymine_properties = "$ENV{HOME}/flymine.properties";
my @dump_command = qw[pg_dump -c];

sub log_message
{
  my $message = shift;
  my $verbose = shift;

  if (defined $message) {
    print LOG "$message\n";
    if (defined $verbose && $verbose) {
      print STDERR "$message\n";
    }
  } else {
    print LOG "\n";
  }
}

sub log_and_print
{
  log_message shift, 1;
}

# run a command and exit the script if it returns a non-zero
sub run_and_check_status
{
  my $command_name = $_[0];

  log_and_print `date`, "\n\n";
  log_and_print "starting command: @_\n";

  open F, "@_ |" or die "can't run @_: $?\n";
  if ($? != 0) {
    log_and_print "failed with exit code $?: @_\n";
    print STDERR "check log: $log_file\n";
    exit $?;
  }

  while (<F>) {
    chomp;
    log_message "  [$command_name] $_";
  }

  log_and_print "finished\n\n";
  log_and_print `date`, "\n\n";
}

# gets a value from a properties file
# usages: get_prop_val prop_name file_name
sub get_prop_val
{
  my $key = shift;
  my $file = shift;

  open F, "$file" or die "cannot open $file: $!\n";

  my $ret_val;

  while (my $line = <F>) {
    if ($line =~ /$key=(.*)/) {
      $ret_val = $1;
    }
  }

  close F;

  return $ret_val;
}

sub dump_db
{
  my $db = shift;
  my $user = shift;
  my $pass = shift;
  my $host = shift;
  my $out_file = shift;

  my @params = ('-U', $user, '-h', $host, '-W', '-f', $out_file, $db);

  log_and_print "\ndumping: @dump_command @params\n";


  my $exp = new Expect;

  $exp->raw_pty(1);
  $exp->spawn("ssh", $dump_host, "@dump_command @params; echo __DUMP_FINISHED__")
    or die "Cannot spawn @dump_command @params: $!\n";

  ## Doesn't work:
  # $exp->slave->stty(qw(-echo));

  $exp->expect(10, 'Password: ');
  $exp->send("$pass\n");
  $exp->expect(9999999, '__DUMP_FINISHED__\n');
  $exp->soft_close();
}

my $prod_host = get_prop_val "db.production.datasource.serverName", $flymine_properties;
my $prod_db = get_prop_val "db.production.datasource.databaseName", $flymine_properties;
my $prod_user = get_prop_val "db.production.datasource.user", $flymine_properties;
my $prod_pass = get_prop_val "db.production.datasource.password", $flymine_properties;

log_message "read properties:";
log_message "  prod_host: $prod_host";
log_message "  prod_db: $prod_db";
log_message "  prod_user: $prod_user";
log_message "  prod_pass: $prod_pass";
log_message;

while (my $line = <DATA>) {
  if ($line =~ m{
                    ^\s*\#
                   |
                    ^\s*$
                }x) {
    next;
  }

  my ($action, @args) = split " ", $line;

  if ($action eq "run:") {
    if ($verbose) {
      run_and_check_status "ant", @args;
    } else {
      run_and_check_status "ant", "-v", @args;
    }
  } else {
    if ($action eq "dump:") {
      if (@args != 1) {
        die "dump: needs one parameter at: $line\n";
      }
      dump_db $prod_db, $prod_user, $prod_pass, $prod_host, $dump_file_prefix . ".$args[0]";
    } else {
      die "unknown action \"$action\"\n";
    }
  }
}

__END__

# lines beginning with "run:" list ant targets to run
# "dump:" lines give the suffix of the postgresql dump file
# actions are executed in order

run: create-production-model compile-genomic-model jar-genomic build-db-production load-static-flymine build-ensembl-anopheles-production

dump: anopheles

run: build-uniprot-production

dump: uniprot

run: build-flybase-production

dump: drosophila

run: build-go-production build-psi-production build-rnai-production
run: build-phenotype-production build-orthologues-production build-protein_structure-production

dump: load-stage1

run: build-flyreg-production build-long_oligo-production build-tiling_path-production build-drosdel-production

dump: load-stage2

run: read-flybase-chromosome-fasta calculate-locations
run: create-references
run: update-orthologues make-spanning-locations create-chromosome-locations-and-lengths
run: create-indexes-production-attribute create-overlap-relations
run: create-symmetrical-relation-references transfer-sequences read-flybase-cds-fasta
run: create-flybase-to-uniprot-refs update-publications

dump: postprocess
